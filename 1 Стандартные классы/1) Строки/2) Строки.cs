



/*
Строки - объекты хранящие набор символов
В конце каждой строки есть \0
Для строк характерно то что обозначаются они через ""
Виды строк:
    string - состоит из char. Не изменяемые строки
        Обозначение: "текст"

    StringBuilder  - состоит из char. Изменяемые строки


В C# строки типа string являются не изменяемыми. 
В отличии от массивов данные строки можно изменить, 
    но при попытке изменения будет создан новый обьект строки

*/


string name = new String('!', 3); // Создание стрики из повторяющевося символа
// (3 - количество символов, "!" символ)
Console.WriteLine($"Переменная name = {name}"); // Вывод текста

name = new String(new char[] { 'w', 'o', 'r', 'l', 'd' }, 1, 3);  // Создание строки из массива
/* Уже созданной переменной даем новое значение
    new char[] { 'w', 'o', 'r', 'l', 'd' } - массив символов
    1 - индекс с которого начать подрезку массива
    3 - количество необходимы символов
*/
Console.WriteLine($"Переменная name = {name}"); // Вывод текста

// Создание многострочной строки
name = new String("""
Создание многочтрочной строки 
    Именно так создается многострочная строка
    Строка обязательно должна начинатся с нового поля та как иначе будет ошибка
"""); 
Console.WriteLine($"Переменная name = {name}"); 

name = new String($"Значение какой-то переменной = {989}"); // Создание форматируемой строки
// В место 989 можно подставить любую переменную
/* Кроме форматирования через $  можно использовать функцию format
    name = string.Format("Значение какой-то переменной = {0}", 989);     
Вместо {0} в строку будет подставленно 989

Вывод типа Console.WriteLine("Значение какой-то переменной = {0}", 989); будет работать так же как и форматная функция

*/
Console.WriteLine($"Переменная name = {name}");

name = "Alex"; // Уже созданной переменной даем новое значение
Console.WriteLine($"Переменная name = {name}"); // Вывод текста

///

Console.WriteLine("\n\tИзменение строки"); 

name = " Alex "; 
name = name.Trim(); // Без аргументов отрезает убирает только пробелы с начала и конца
Console.WriteLine($"Обрезка строки: {name}"); 
name = name.Trim('A', 'x'); // Обрезаем буквы 'A' и 'x' с начала и конца
Console.WriteLine($"Обрезка строки: {name}"); 
name = "Alex";
/* Метод Trim имеет аналоги.
TrimStart - работает точно так же как и Trim, но работает только с началом строки
TrimEnd - работает точно так же как и Trim, но работает только с концом строки
*/


name = name.Insert(4, "Name Carl Lon"); // Вставка подстроки
/* Содержит следующие аргументы
    "переменная в которую сохраняем результат" = "обьект к которому применяем".Insert(
    индекс_с_которого_начать(для_обьекта), "текст который хотим вставить");
*/
Console.WriteLine($"Строка после вставки: {name}"); 

name = name.Remove(13, 4);
/* Содержит следующие аргументы
    "обьект к которому применяем".Remove(
    индекс_с_которого_начать(для_обьекта), количество_удаляемых_символов)
количество_удаляемых_символов - данный параметр не обязателен, 
    но без его указания будет удален только тот символ, на который указывает индекс
*/
Console.WriteLine($"Строка после удаления подстроки: {name}"); 


name = name.Replace("Name Carl", " Merfi"); // Замена подстроки
/* Содержит следующие аргументы
    "переменная в которую сохраняем результат" = "обьект к которому применяем".replace(
        текст который хотим заменить(для_обьекта), текст на который хотим заменить)
*/
Console.WriteLine($"Строка после замены: {name}"); 

name = name.ToUpper(); // Замена регистра строки
/*ToUpper() - устаналивает верхний регист (большие буквы)
ToLower() - устаналивает нижний регист (маленькие буквы)*/
Console.WriteLine($"Строка после регистра: {name}"); 




    /*name.append(" Merfi"); // Добавление текста в конец строки
    // name.append(" ").append("Merfi"); // Можно добавлять по цепочке
    cout << "name после добавления подстроки: " << name << "\n";
   /* cout << "name после вставки подстроки: " << name << "\n";

    /*cout << "name после замены подстроки: " << name << "\n";
    name.erase(4, 6); // Удаление подстроки*/
    /* Содержит следующие аргументы
    "обьект к которому применяем".erase(индекс_с_которого_начать(для_обьекта), 
        количество_удаляемых_символов
    )
    Если количество_удаляемых_символов больше оставшихся, то будут удалены имеющиеся символы
    */
    //cout << "name после удаления подстроки: " << name << "\n";





///


Console.WriteLine("\n\tВзаимодействие со строками"); 

Console.WriteLine($"Проверка на пустоту строки: {name.Length == 0}" );
Console.WriteLine($"Определение размера строки (количество символов) = {name.Length}");  
Console.WriteLine($"Конкатенация строк через +: Name = " + name);
Console.WriteLine(string.Concat("Конкатенация строк через Concat: Name = ", name));
{
    string temp = "23:08:2024"; 
    string[] values = temp.Split(new char[] {':', });// Создаем массив строк
    /*
    В качестве параметра функция принимает массив символов / символ по которым нужно разбить строку
        string[] values2 = temp.Split(":"); // Создаем массив строк
    Так же в качестве параметра можно использовать строку
    */
    Console.WriteLine($"Обьединение массива строк (который был получен через Split) с помощью Join = " + string.Join(".", values));
    // values - массив строк; "." - символ объединитель
}


///


Console.WriteLine("\n\tВзаимодействие с подстроками"); 
    
Console.WriteLine("Получение подстроки: " + name.Substring(1, 2)); 
// Первый параметр представляет индекс, с которого начинается подстрока. 
// Второй параметр - количество символов извлекаемой подстроки. Если второго параметра нет, то возьмет все что есть
    Console.WriteLine("Поиск индекса подстроки/символа с начала строки: " + name.IndexOf("le")); 
    Console.WriteLine("Поиск индекса подстроки/символа с конца строки: " + name.LastIndexOf("le")); 
// Если строка или символ не найдены, то возвращается -1
Console.WriteLine("Проверка начала строки на совпадание: " + name.StartsWith("Al")); 
Console.WriteLine("Проверка конца строки на совпадание: " + name.EndsWith("ex")); 




///

Console.WriteLine("\n\tЛогические операции:");
/* Логические операции:
    >  - вернет true если:
        левая строка > по количеству символов правой 
        при одинаковой длине код символов левой строки > кода символа правой строки

    >=  - вернет true если:
        левая строка >= по количеству символов правой 
        при одинаковой длине код символов левой строки >= кода символа правой строки

    <  - вернет true если:
        левая строка < по количеству символов правой 
        при одинаковой длине код символов левой строки < кода символа правой строки

    <= - вернет true если:
        левая строка <= по количеству символов правой 
        при одинаковой длине код символов левой строки <= кода символа правой строки

    == - вернет true если строки одинаковые
    != - вернет true если строки не одинаковые

    string.Compare("текущая строка", "строка с которой сравниваем") вернет:
        0 - строки равны
        больше 0 - текущая строка больше
        меньше 0 -  текущая строка меньше
*/
Console.WriteLine($"Логические операция == : {name == "Alex"}");
Console.WriteLine($"Логические операция compare : {string.Compare(name, "Ale")}");


///

Console.WriteLine("\n\tИтерация строки:");
Console.Write("Вывод name через цикл по символам (с помощью индексации): ");
for (int i = 0; i < name.Length; i +=1){
    Console.Write(name[i]);
}
Console.WriteLine("");

Console.Write("Вывод name через цикл по символам (с цикла foreach): ");
foreach (char sim in name){
    Console.Write(sim);
}
Console.WriteLine("");

